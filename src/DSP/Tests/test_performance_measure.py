'''
Created on Feb 21, 2020

@author: paepcke
'''

import csv
import sys, os
import unittest

from DSP.precision_recall_from_wav import PrecRecComputer, ElephantEvent
import numpy as np

sys.path.append(os.path.dirname(__file__))
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))

TEST_ALL = True
#TEST_ALL = False

class TestDSPPerformanceComputation(unittest.TestCase):
    '''
    Using tiny_labels_for_testing.txt for labels, we
    have ele activity at seconds:
        1...2
        3...5
        7...8
        
    Therefore, with framerate == 2, ele labels are at samples
    (0-origin):
     	2...4   incl. 2, excl 4
    	6...10
       14...16
       
    Test cases:
        1. 100% correct audio:
           audio mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0

        2. First burst is false negative:
           audio mask:  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0
        
        3. The third element of the four negatives after the second burst
           is a false positive:
           audio mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0
        
        4. First and last elements are false positive: 
           audio mask:  1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0
             
        5. Audio bleeds two events together:
           audio mask:  0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0

        6. Insufficient overlap (50%)
           audio mask:  0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0
             
    '''

    def setUp(self):
        unittest.TestCase.setUp(self)

        self.samples_for_voltage_suppression = np.array([1,12,13,14,5,4,3,20])
        
        self.samples_normal_immediate_start = np.array([1,0,0,10,11,0,0,0,0,20])
        self.samples_normal_immediate_start_sig_index = np.array([0,3,4,9])

        self.samples_for_attack_and_release = np.array([0,0,0,0,1,0.8,0,0,0,0,0,0,0,0,0.4])
        self.samples_for_attack_and_release_sig_index = np.array([4,14])
        
        self.label_file_path = os.path.join(os.path.dirname(__file__), 'labels_for_testing.txt')
        
        # Example audio voltage sequences. Each used in 
        # a separate test method:
        self.samples1 = np.array([0, 0, 10, 3, 0, 0, 5, 6, 2, 7, 0, 0, 0, 0, 1, 2, 0])
        self.samples2 = np.array([0, 0, 0, 0, 0, 0, 5, 6, 2, 7, 0, 0, 0, 0, 1, 2, 0])
        self.samples3 = np.array([0, 0, 10, 3, 0, 0, 5, 6, 2, 7, 0, 0, 1, 0, 1, 2, 0])
        self.samples4 = np.array([10, 0, 10, 3, 0, 0, 5, 6, 2, 7, 0, 0, 0, 0, 1, 2, 20])
        self.samples5 = np.array([0, 0, 20, 3, 4, 2, 7, 2, 0, 0, 0, 0, 0, 0, 30, 21, 0])
        self.samples6 = np.array([0, 0, 32, 3, 0, 0, 0, 0, 20, 24, 13, 11, 0, 0, 10, 1, 0])
        
        # A synthetic file of labels as generated by Raven:
        self.tiny_labels_path = os.path.join(os.path.dirname(__file__), 'tiny_labels_for_testing.txt')

        self.pr_comp = PrecRecComputer(None,  # No wavefile; we'll pass artificial samples 
                                       self.label_file_path, 
                                       print_res=False, 
                                       plot=False,
                                       testing=True)

    #------------------------------------
    # test_compute_overlap_percentage
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_compute_overlap_percentage(self):
        '''
        Test computation of overlap audio with 
        label. Cases:

        Perfect overlap:
        
         audio    ***************
         label    ---------------
         
         
         Audio shifted left:
         audio    ***************
         label            ---------------
         
         Audio shifted right:
         audio             ***************
         label    ---------------
        '''
        
        # Perfect overlap:
        aud_begin = el_begin = 10
        aud_end   = el_end   = 20
        self.assertEqual(self.pr_comp.compute_overlap_percentage(aud_begin, aud_end, el_begin, el_end),
                         100.0)
        
        # Audio left shifted:
        aud_begin = 0
        el_begin  = 10
        aud_end   = 15
        el_end    = 20
        
        self.assertEqual(self.pr_comp.compute_overlap_percentage(aud_begin, aud_end, el_begin, el_end),
                         50.0)
        
        # Audio right shifted:
        aud_begin = 15
        el_begin  = 10
        aud_end   = 25
        el_end    = 20
        
        self.assertEqual(self.pr_comp.compute_overlap_percentage(aud_begin, aud_end, el_begin, el_end),
                         50.0)
        
        # No overlap:
        aud_begin = 0
        el_begin  = 10
        aud_end   = 5
        el_end    = 20
        
        self.assertEqual(self.pr_comp.compute_overlap_percentage(aud_begin, aud_end, el_begin, el_end),
                         0.0)

        # Both start together, but audio longer:
        aud_begin = 10
        el_begin  = 10
        aud_end   = 25
        el_end    = 20
        self.assertEqual(self.pr_comp.compute_overlap_percentage(aud_begin, aud_end, el_begin, el_end),
                         100.0)

        # Both end together, but audio longer:
        aud_begin = 0
        el_begin  = 10
        aud_end   = 20
        el_end    = 20
        
        self.assertEqual(self.pr_comp.compute_overlap_percentage(aud_begin, aud_end, el_begin, el_end),
                         100.0)


    #------------------------------------
    # test_label_reader
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_label_reader(self):
        labeled_events = self.read_labels()
        self.assertEqual(len(labeled_events), 5)
        first_evnt = labeled_events[0]
        self.assertEqual(first_evnt.begin_time, 1.293)
        self.assertEqual(first_evnt.end_time, 6.464999999991385)
        self.assertEqual(first_evnt.selection_index, 1)
        
    #------------------------------------
    # test_collect_audio_events
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_collect_audio_events(self):

        audio_events = self.pr_comp.collect_audio_events(np.array([0, 0, 1, 1, 1, 0, 1, 1]))
        # Should get two audio event objects:
        #    start_sample: 2
        #      end_sample: 5
        #    start_sample: 6
        #      end_sample: 8
        
        self.assertEqual(len(audio_events), 2)
        self.assertEqual(audio_events[0].begin_time, 2)
        self.assertEqual(audio_events[0].end_time, 5)
        
        self.assertEqual(audio_events[1].begin_time, 6)
        self.assertEqual(audio_events[1].end_time, 8)
        
        # Again, with burst right at the start:
        audio_events = self.pr_comp.collect_audio_events(np.array([1, 0, 1, 1, 1, 0, 1, 0]))
        self.assertEqual(len(audio_events), 3)
        self.assertEqual(audio_events[0].begin_time, 0)
        self.assertEqual(audio_events[0].end_time, 1)
        
        self.assertEqual(audio_events[1].begin_time, 2)
        self.assertEqual(audio_events[1].end_time, 5)
        
        self.assertEqual(audio_events[2].begin_time, 6)
        self.assertEqual(audio_events[2].end_time, 7)
        
        # No events at all:
        audio_events = self.pr_comp.collect_audio_events(np.array([0, 0, 0, 0, 0, 0, 0, 0]))
        self.assertEqual(len(audio_events), 0)
        
        # One big burst:
        burst = np.array([1, 1, 1, 1, 1, 1, 1, 1])
        audio_events = self.pr_comp.collect_audio_events(burst)
        self.assertEqual(len(audio_events), 1)
        
        self.assertEqual(audio_events[0].begin_time, 0)
        self.assertEqual(audio_events[0].end_time, burst.size)

    #------------------------------------
    # test_get_total_labeled_samples
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_get_total_labeled_samples(self):
        
        # For testing PrecRecComputer sets sample rate to
        # PrecRecComputer.SAMPLE_RATE_FOR_TESTING
        
        # Label: selection number 1, second 2 to 4:
        event1 = ElephantEvent(1, 2.0, 4.0)
        
        # Framerate times event duration in seconds:
        correct_num_samples = PrecRecComputer.SAMPLE_RATE_FOR_TESTING * 2.0
        num_samples = self.pr_comp.get_total_labeled_samples(np.array([event1]))
        self.assertEqual(num_samples, correct_num_samples)

        # No event passed in:
        num_samples = self.pr_comp.get_total_labeled_samples(np.array([]))
        self.assertEqual(num_samples, 0)

        # Fractional begin/end seconds:
        event2 = ElephantEvent(2, 2.1234, 4.678)
        # Rounding up the end time, we get a 3 sec duration:
        correct_num_samples = PrecRecComputer.SAMPLE_RATE_FOR_TESTING * 3.0
        num_samples = self.pr_comp.get_total_labeled_samples(np.array([event2]))
        self.assertEqual(num_samples, correct_num_samples)
    
    #------------------------------------
    # test_get_el_and_aud_masks
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_get_el_and_aud_masks(self):
        
        # To keep array lengths small:
        self.pr_comp.framerate = 2 # samples/sec
        
        # Normal type of case:
        
        samples   = np.array([0, 0, 10, 3, 6, 0, 23, 103])
        el_labels = np.array([ElephantEvent(1, 2, 4)])

        (samples_mask, labels_mask) = self.pr_comp.get_el_and_aud_masks(samples, el_labels)

        samples_correct   = np.array([0,0,1,1,1,0,1,1])

        # Labels: start mask position to set to 1: framrate * begin_time, 
        #         end mask position to set to 1  : framerate * end_time.
        # [2*2, 2*4] == [4,8] ==> [positions 3 through 7 
        el_labels_correct = np.array([0,0,0,1,1,1,1,0])
        
        self.assertEqual(all(samples_mask), all(samples_correct))
        self.assertEqual(all(labels_mask),  all(el_labels_correct))

        # All samples 0:
        samples   = np.array([0, 0, 0, 0, 0, 0, 0, 0])

        (samples_mask, labels_mask) = self.pr_comp.get_el_and_aud_masks(samples, el_labels)
        samples_correct   = np.array([0,0,0,0,0,0,0,0])
        el_labels_correct = np.array([0,0,0,1,1,1,1,0])
        
        self.assertEqual(all(samples_mask), all(samples_correct))
        self.assertEqual(all(labels_mask),  all(el_labels_correct))

        # All samples 1:
        samples   = np.array([1, 1, 1, 1, 1, 1, 1, 1])

        (samples_mask, labels_mask) = self.pr_comp.get_el_and_aud_masks(samples, el_labels)
        samples_correct   = np.array([1,1,1,1,1,1,1,1])
        el_labels_correct = np.array([0,0,0,1,1,1,1,0])
        
        self.assertEqual(all(samples_mask), all(samples_correct))
        self.assertEqual(all(labels_mask),  all(el_labels_correct))

        # Empty labels:
        
        samples   = np.array([0, 0, 10, 3, 6, 0, 23, 103])
        el_labels = np.array([])

        (samples_mask, labels_mask) = self.pr_comp.get_el_and_aud_masks(samples, el_labels)

        samples_correct   = np.array([0,0,1,1,1,0,1,1])
        el_labels_correct = np.array([0,0,0,0,0,0,0,0])

        self.assertEqual(all(samples_mask), all(samples_correct))
        self.assertEqual(all(labels_mask),  all(el_labels_correct))

    #------------------------------------
    # test_total_overlap
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_total_overlap(self):
        '''
        Audio perfectly predicts labels:
           audio mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0

        '''

        # To make arrays small:
        self.pr_comp.framerate = 2
        
        # SAMPLE 1: total overlap
        with open(self.tiny_labels_path, 'r') as fd:
            reader = csv.reader(fd, delimiter='\t')
            perf_res = self.pr_comp.compute_performance(self.samples1, reader, 100) # 100% overlap for success
        
        self.assertEqual(perf_res.recall_events, 1)
        self.assertEqual(perf_res.precision_events, 1)
        self.assertEqual(perf_res.f1score_events, 1.0)

        self.assertEqual(perf_res.recall_samples, 1)
        self.assertEqual(perf_res.precision_samples, 1)
        self.assertEqual(perf_res.f1score_samples, 1.0)
        
        correct_conf_matrix_events = np.array([3, 0,
                                               0, 9
                                               ])
        correct_conf_matrix_samples = np.array([8, 0,
                                                0, 9
                                                ])
        self.assertEqual(np.all(perf_res.confusion_matrix_events),
                         np.all(correct_conf_matrix_events)
                         )
        self.assertEqual(np.all(perf_res.confusion_matrix_samples),
                         np.all(correct_conf_matrix_samples)
                         )

    #------------------------------------
    # test_compute_performance
    #-------------------    

    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_compute_performance(self):
        '''
        Test cases using sample2:

        2. First burst is false negative:
           audio mask:  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0

        '''

        # To make arrays small:
        self.pr_comp.framerate = 2
        
        # SAMPLE 2: Audio has two false negatives
        
        with open(self.tiny_labels_path, 'r') as fd:
            reader = csv.reader(fd, delimiter='\t')
            perf_res = self.pr_comp.compute_performance(self.samples2, reader, 100) # 100% overlap for success
        
        self.assertEqual(np.round(perf_res.recall_events, 2), 0.67) # 2/3
        self.assertEqual(np.round(perf_res.precision_events, 2), 1.0)  # no false positives
        self.assertEqual(np.round(perf_res.f1score_events, 2), 0.80)

        self.assertEqual(np.round(perf_res.recall_samples, 2), 0.75) # 6/8
        self.assertEqual(np.round(perf_res.precision_samples, 2), 1) # no false positives
        self.assertEqual(np.round(perf_res.f1score_samples, 2), 0.86)
        
        correct_conf_matrix_events = np.array([2, 0,
                                               1, 9
                                               ])
        correct_conf_matrix_samples = np.array([6, 0,
                                                2, 9
                                                ])
        self.assertEqual(np.all(perf_res.confusion_matrix_events),
                         np.all(correct_conf_matrix_events)
                         )
        self.assertEqual(np.all(perf_res.confusion_matrix_samples),
                         np.all(correct_conf_matrix_samples)
                         )

    #------------------------------------
    # test_false_positive
    #------------------- 
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_false_positive(self):
        '''
        3. The third element of the four negatives after the second burst
           is a false positive:
           audio mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0

        '''
        # To make arrays small:
        self.pr_comp.framerate = 2
        
        # SAMPLE 3: Audio has one false positive:
        
        with open(self.tiny_labels_path, 'r') as fd:
            reader = csv.reader(fd, delimiter='\t')
            perf_res = self.pr_comp.compute_performance(self.samples3, reader, 100) # 100% overlap for success
        
        self.assertEqual(np.round(perf_res.recall_events, 2), 1) # got them all
        self.assertEqual(np.round(perf_res.precision_events, 2), 0.75)  # 3 of the claimed 4 are right
        self.assertEqual(np.round(perf_res.f1score_events, 2), 0.86)

        self.assertEqual(np.round(perf_res.recall_samples, 2), 1) # got them all
        self.assertEqual(np.round(perf_res.precision_samples, 2), 0.89) # 1 false positive sample
        self.assertEqual(np.round(perf_res.f1score_samples, 2), 0.94)
        
        correct_conf_matrix_events = np.array([3, 1,
                                               0, 8
                                               ])
        correct_conf_matrix_samples = np.array([8, 1,
                                                0, 8
                                                ])
        self.assertEqual(np.all(perf_res.confusion_matrix_events),
                         np.all(correct_conf_matrix_events)
                         )
        self.assertEqual(np.all(perf_res.confusion_matrix_samples),
                         np.all(correct_conf_matrix_samples)
                         )

    #------------------------------------
    # test_false_positives_at_edges
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_false_positives_at_edges(self):
        '''
        4. First and last elements are false positive: 
           audio mask:  1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0

        '''
        # To make arrays small:
        self.pr_comp.framerate = 2
        
        # SAMPLE 4: Audio has two false positive; one at each end:
        
        with open(self.tiny_labels_path, 'r') as fd:
            reader = csv.reader(fd, delimiter='\t')
            perf_res = self.pr_comp.compute_performance(self.samples4, reader, 100) # 100% overlap for success
        
        self.assertEqual(np.round(perf_res.recall_events, 2), 1) # got them all
        self.assertEqual(np.round(perf_res.precision_events, 2), 0.75)  # 3 of the claimed 4 are right
        self.assertEqual(np.round(perf_res.f1score_events, 2), 0.86)

        self.assertEqual(np.round(perf_res.recall_samples, 2), 1) # got them all
        self.assertEqual(np.round(perf_res.precision_samples, 2), 0.80) # 8/10: 2 false positive samples of 10 claimed
        self.assertEqual(np.round(perf_res.f1score_samples, 2), 0.89)
        
        correct_conf_matrix_events = np.array([3, 1,
                                               0, 7
                                               ])
        correct_conf_matrix_samples = np.array([8, 2,
                                                0, 7
                                                ])
        self.assertEqual(np.all(perf_res.confusion_matrix_events),
                         np.all(correct_conf_matrix_events)
                         )
        self.assertEqual(np.all(perf_res.confusion_matrix_samples),
                         np.all(correct_conf_matrix_samples)
                         )

    #------------------------------------
    # test_insufficient_overlap
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_insufficient_overlap(self):
        '''
        6. Insufficient overlap (50%)
           audio mask:  0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0
        
        '''

        # To make arrays small:
        self.pr_comp.framerate = 2
        
        # SAMPLE 6: Audio has same number of 1s, but one
        #           event is shifted right by 50%:
        
        with open(self.tiny_labels_path, 'r') as fd:
            reader = csv.reader(fd, delimiter='\t')
            perf_res = self.pr_comp.compute_performance(self.samples6, reader, 100) # 100% overlap for success
        
        self.assertEqual(np.round(perf_res.recall_events, 2), 0.67) # got 2 of 3: insufficent overlap
        self.assertEqual(np.round(perf_res.precision_events, 2), 0.67)  # the gotten ones are ok by *number*
        self.assertEqual(np.round(perf_res.f1score_events, 2), .67)

        self.assertEqual(np.round(perf_res.recall_samples, 2), 0.75) # found 6 of 8
        self.assertEqual(np.round(perf_res.precision_samples, 2), 0.75) # 6 of 8 are correct
        self.assertEqual(np.round(perf_res.f1score_samples, 2), 0.75)
        
        correct_conf_matrix_events = np.array([2, 1,
                                               1, 7
                                               ])
        correct_conf_matrix_samples = np.array([6, 2,
                                                2, 7
                                                ])
        self.assertEqual(np.all(perf_res.confusion_matrix_events),
                         np.all(correct_conf_matrix_events)
                         )
        self.assertEqual(np.all(perf_res.confusion_matrix_samples),
                         np.all(correct_conf_matrix_samples)
                         )

# --------------------------- Utils ---------------------

    #------------------------------------
    # read_labels
    #-------------------    

    def read_labels(self):
        
        with open(os.path.join(os.path.dirname(__file__), 'labels_for_testing.txt'), 'r') as fd:
            reader = csv.reader(fd, delimiter='\t')
            labeled_events = self.pr_comp.label_file_reader(reader)
            return labeled_events 

# --------------------------- Main ---------------
        
if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()