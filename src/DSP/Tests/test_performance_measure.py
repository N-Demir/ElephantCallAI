'''
Created on Feb 21, 2020

@author: paepcke
'''

import sys, os
import unittest

sys.path.append(os.path.dirname(__file__))
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))

from DSP.precision_recall_from_wav import PrecRecComputer, ElephantEvent, AudioEvent
import numpy as np


TEST_ALL = True
#TEST_ALL = False

class TestDSPPerformanceComputation(unittest.TestCase):
    '''
    Using tiny_labels_for_testing.txt for labels, we
    have ele activity at seconds:
        1...2
        3...5
        7...8
        
    Therefore, with framerate == 2, ele labels are at samples
    (0-origin):
     	2...4   incl. 2, excl 4
    	6...10
       14...16
       
    Test cases:
        1. 100% correct audio:
           audio mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0

        2. First burst is false negative:
           audio mask:  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0
        
        3. The third element of the four negatives after the second burst
           is a false positive:
           audio mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0
        
        4. First and last elements are false positive: 
           audio mask:  1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0
             
        5. Audio bleeds two events together:
           audio mask:  0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0

        6. Insufficient overlap (50%)
           audio mask:  0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0
             
    '''

    def setUp(self):
        unittest.TestCase.setUp(self)

        self.samples_for_voltage_suppression = np.array([1,12,13,14,5,4,3,20])
        
        self.samples_normal_immediate_start = np.array([1,0,0,10,11,0,0,0,0,20])
        self.samples_normal_immediate_start_sig_index = np.array([0,3,4,9])

        self.samples_for_attack_and_release = np.array([0,0,0,0,1,0.8,0,0,0,0,0,0,0,0,0.4])
        self.samples_for_attack_and_release_sig_index = np.array([4,14])
        
        self.label_file_path = os.path.join(os.path.dirname(__file__), 'labels_for_testing.txt')
        
        # Example audio voltage sequences. Each used in 
        # a separate test method:
        self.samples1 = np.array([0, 0, 10, 3, 0, 0, 5, 6, 2, 7, 0, 0, 0, 0, 1, 2, 0])
        self.samples2 = np.array([0, 0, 0, 0, 0, 0, 5, 6, 2, 7, 0, 0, 0, 0, 1, 2, 0])
        self.samples3 = np.array([0, 0, 10, 3, 0, 0, 5, 6, 2, 7, 0, 0, 1, 0, 1, 2, 0])
        self.samples4 = np.array([10, 0, 10, 3, 0, 0, 5, 6, 2, 7, 0, 0, 0, 0, 1, 2, 20])
        self.samples5 = np.array([0, 0, 20, 3, 4, 2, 7, 2, 0, 0, 0, 0, 0, 0, 30, 21, 0])
        self.samples6 = np.array([0, 0, 32, 3, 0, 0, 0, 0, 20, 24, 13, 11, 0, 0, 10, 1, 0])
        
        # A synthetic file of labels as generated by Raven:
        self.tiny_labels_path = os.path.join(os.path.dirname(__file__), 'tiny_labels_for_testing.txt')

        self.pr_comp = PrecRecComputer(None,  # No signal treatment
                                       None,  # No wavefile; we'll pass artificial samples 
                                       self.label_file_path, 
                                       print_res=False, 
                                       testing=True)

    #------------------------------------
    # test_compute_overlap_percentage
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_compute_overlap_percentage(self):
        '''
        Test computation of overlap audio with 
        label. Cases:

        Perfect overlap:
        
         audio    ***************
         label    ---------------
         
         
         Audio shifted left:
         audio    ***************
         label            ---------------
         
         Audio shifted right:
         audio             ***************
         label    ---------------
        '''
        
        # Perfect overlap:
        aud_begin = el_begin = 10
        aud_end   = el_end   = 20
        aud_indices = np.array([(aud_begin, aud_end)], dtype=int)
        ele_indices = np.array([(el_begin, el_end)], dtype=int)
        res_dict    = self.pr_comp.compute_overlap_percentage(aud_indices,ele_indices)
        self.assertEqual(res_dict['percent_overlaps'], [100.0]) 

        # Audio left shifted
        #   10,20  el
        #    0,15  aud
        el_begin  = 10
        el_end    = 20
        aud_begin = 0
        aud_end   = 15
        aud_indices = np.array([(aud_begin, aud_end)], dtype=int)
        ele_indices = np.array([(el_begin, el_end)], dtype=int)
        res_dict    = self.pr_comp.compute_overlap_percentage(aud_indices,
                                                              ele_indices)

        self.assertEqual(res_dict['percent_overlaps'], [50.0]) 
        
        
        # Audio right shifted:
        #   10,20  el
        #   15,25  aud
        aud_begin = 15
        el_begin  = 10
        aud_end   = 25
        el_end    = 20
        
        aud_indices = np.array([(aud_begin, aud_end)], dtype=int)
        ele_indices = np.array([(el_begin, el_end)], dtype=int)
        res_dict    = self.pr_comp.compute_overlap_percentage(aud_indices,
                                                              ele_indices)

        self.assertEqual(res_dict['percent_overlaps'], [50.0]) 

        
        # No overlap:
        #   10,20  el
        #   15,25  aud
        el_begin  = 10
        el_end    = 20
        aud_begin = 25
        aud_end   = 30
        
        aud_indices = np.array([(aud_begin, aud_end)], dtype=int)
        ele_indices = np.array([(el_begin, el_end)], dtype=int)
        res_dict    = self.pr_comp.compute_overlap_percentage(aud_indices,
                                                              ele_indices)

        self.assertEqual(res_dict['percent_overlaps'], []) 

        # Both start together, but audio longer on right:
        #   10,20  el
        #   10,25  aud
 
        aud_begin = 10
        el_begin  = 10
        aud_end   = 25
        el_end    = 20

        aud_indices = np.array([(aud_begin, aud_end)], dtype=int)
        ele_indices = np.array([(el_begin, el_end)], dtype=int)
        res_dict    = self.pr_comp.compute_overlap_percentage(aud_indices,
                                                              ele_indices)

        self.assertEqual(res_dict['percent_overlaps'], [100.0])        

        # Both end together, but audio longer on left:
        #   10,20  el
        #   0 ,20  aud
        
        aud_begin = 0
        el_begin  = 10
        aud_end   = 20
        el_end    = 20
        
        aud_indices = np.array([(aud_begin, aud_end)], dtype=int)
        ele_indices = np.array([(el_begin, el_end)], dtype=int)
        res_dict    = self.pr_comp.compute_overlap_percentage(aud_indices,
                                                              ele_indices)

        self.assertEqual(res_dict['percent_overlaps'], [100.0])        

    #------------------------------------
    # test_label_reader
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_label_reader(self):
        (labeled_events, _mask) = self.read_labels()
        self.assertEqual(len(labeled_events), 5)
        evt_list = []
        for (sel_indx, start_end_arr) in enumerate(labeled_events):
            evt_list.append(ElephantEvent(sel_indx+1, # Needs to be 1-based 
                                          *start_end_arr))
        
        first_evnt = evt_list[0]
        self.assertEqual(first_evnt.begin_time, 
                         int(1.293*self.pr_comp.framerate))
        self.assertEqual(first_evnt.end_time, 25861)
        self.assertEqual(first_evnt.selection_index, 1)
        
    #------------------------------------
    # test_collect_audio_events
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_collect_audio_events(self):

        (audio_event_matrix, _mask) = \
            self.pr_comp.collect_audio_events(np.array([0, 0, 1, 1, 1, 0, 1, 1]))
        # Should get two audio event objects:
        #    start_sample: 2
        #      end_sample: 5
        #    start_sample: 6
        #      end_sample: 8
        
        self.assertEqual(len(audio_event_matrix), 2)
        # Iterate through the rows, each of which is
        # a being/end audio event. Each iteration yields
        # a being/end index list. The * operator turns that
        # into the two args required for AudioEvent(): begin
        # and end:
        aud_events = [AudioEvent(*row) for row in iter(audio_event_matrix)]
        self.assertEqual(aud_events[0].begin_time, 2)
        self.assertEqual(aud_events[0].end_time, 5)
        
        self.assertEqual(aud_events[1].begin_time, 6)
        self.assertEqual(aud_events[1].end_time, 8)

        # Again, with burst right at the start:
        (audio_event_matrix, _mask) = \
            self.pr_comp.collect_audio_events(np.array([1, 0, 1, 1, 1, 0, 1, 0]))
        self.assertEqual(len(audio_event_matrix), 3)
        aud_events = [AudioEvent(*row) for row in iter(audio_event_matrix)]
        self.assertEqual(aud_events[0].begin_time, 0)
        self.assertEqual(aud_events[0].end_time, 1)

        self.assertEqual(aud_events[1].begin_time, 2)
        self.assertEqual(aud_events[1].end_time, 5)
        
        self.assertEqual(aud_events[2].begin_time, 6)
        self.assertEqual(aud_events[2].end_time, 7)
                
        # No events at all:
        (audio_event_matrix, _mask) = \
            self.pr_comp.collect_audio_events(np.array([0, 0, 0, 0, 0, 0, 0, 0]))
        self.assertEqual(len(audio_event_matrix), 0)
        
        # One big burst:
        burst = np.array([1, 1, 1, 1, 1, 1, 1, 1])
        (audio_event_matrix, _mask) = \
            self.pr_comp.collect_audio_events(burst)
        aud_events = [AudioEvent(*row) for row in iter(audio_event_matrix)]
        self.assertEqual(len(audio_event_matrix), 1)
        aud_events = [AudioEvent(*row) for row in iter(audio_event_matrix)]
        self.assertEqual(aud_events[0].begin_time, 0)
        self.assertEqual(aud_events[0].end_time, burst.size)

    #------------------------------------
    # test_get_total_labeled_samples
    #-------------------
    
#     @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
#     def test_get_total_labeled_samples(self):
#         
#         # For testing PrecRecComputer sets sample rate to
#         # PrecRecComputer.SAMPLE_RATE_FOR_TESTING
#         
#         # Label: selection number 1, second 2 to 4:
#         event1 = ElephantEvent(1, 2.0, 4.0)
#         
#         # Framerate times event duration in seconds:
#         correct_num_samples = PrecRecComputer.SAMPLE_RATE_FOR_TESTING * 2.0
#         num_samples = self.pr_comp.get_total_labeled_samples(np.array([event1]))
#         self.assertEqual(num_samples, correct_num_samples)
# 
#         # No event passed in:
#         num_samples = self.pr_comp.get_total_labeled_samples(np.array([]))
#         self.assertEqual(num_samples, 0)
# 
#         # Fractional begin/end seconds:
#         event2 = ElephantEvent(2, 2.1234, 4.678)
#         # Rounding up the end time, we get a 3 sec duration:
#         correct_num_samples = PrecRecComputer.SAMPLE_RATE_FOR_TESTING * 3.0
#         num_samples = self.pr_comp.get_total_labeled_samples(np.array([event2]))
#         self.assertEqual(num_samples, correct_num_samples)
    
#     #------------------------------------
#     # test_get_el_and_aud_masks
#     #-------------------
#     
#     @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
#     def test_get_el_and_aud_masks(self):
#         
#         # To keep array lengths small:
#         self.pr_comp.framerate = 2 # samples/sec
#         
#         # Normal type of case:
#         
#         samples   = np.array([0, 0, 10, 3, 6, 0, 23, 103])
#         el_labels = np.array([ElephantEvent(1, 2, 4)])
# 
#         (samples_mask, labels_mask) = \
#             self.pr_comp.get_el_and_aud_masks(samples, el_labels)
# 
#         samples_correct   = np.array([0,0,1,1,1,0,1,1])
# 
#         # Labels: start mask position to set to 1: framrate * begin_time, 
#         #         end mask position to set to 1  : framerate * end_time.
#         # [2*2, 2*4] == [4,8] ==> [positions 3 through 7 
#         el_labels_correct = np.array([0,0,0,1,1,1,1,0])
#         
#         self.assertEqual(all(samples_mask), all(samples_correct))
#         self.assertEqual(all(labels_mask),  all(el_labels_correct))
# 
#         # All samples 0:
#         samples   = np.array([0, 0, 0, 0, 0, 0, 0, 0])
# 
#         (samples_mask, labels_mask) = self.pr_comp.get_el_and_aud_masks(samples, el_labels)
#         samples_correct   = np.array([0,0,0,0,0,0,0,0])
#         el_labels_correct = np.array([0,0,0,1,1,1,1,0])
#         
#         self.assertEqual(all(samples_mask), all(samples_correct))
#         self.assertEqual(all(labels_mask),  all(el_labels_correct))
# 
#         # All samples 1:
#         samples   = np.array([1, 1, 1, 1, 1, 1, 1, 1])
# 
#         (samples_mask, labels_mask) = self.pr_comp.get_el_and_aud_masks(samples, el_labels)
#         samples_correct   = np.array([1,1,1,1,1,1,1,1])
#         el_labels_correct = np.array([0,0,0,1,1,1,1,0])
#         
#         self.assertEqual(all(samples_mask), all(samples_correct))
#         self.assertEqual(all(labels_mask),  all(el_labels_correct))
# 
#         # Empty labels:
#         
#         samples   = np.array([0, 0, 10, 3, 6, 0, 23, 103])
#         el_labels = np.array([])
# 
#         (samples_mask, labels_mask) = self.pr_comp.get_el_and_aud_masks(samples, el_labels)
# 
#         samples_correct   = np.array([0,0,1,1,1,0,1,1])
#         el_labels_correct = np.array([0,0,0,0,0,0,0,0])
# 
#         self.assertEqual(all(samples_mask), all(samples_correct))
#         self.assertEqual(all(labels_mask),  all(el_labels_correct))

    #------------------------------------
    # test_total_overlap
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_total_overlap(self):
        '''
        Audio perfectly predicts labels:
           audio mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0

        '''

        # To make arrays small:
        self.pr_comp.framerate = 2
        
        # SAMPLE 1: total overlap
        perf_res = self.pr_comp.compute_performance(None,
                                                    self.samples1, 
                                                    self.tiny_labels_path, 
                                                    100) # 100% overlap for success

        # Sample level:
        self.assertEqual(round(perf_res['recall_samples'], 2), 0.73)
        self.assertEqual(perf_res['precision_samples'], 1)
        self.assertEqual(round(perf_res['f1score_samples'], 2), 0.84)

        correct_conf_matrix_samples = np.array([8, 0,
                                                3, 7
                                                ])

        self.assertEqual(np.all(perf_res.confusion_matrix_samples()),
                         np.all(correct_conf_matrix_samples)
                         )
        # Event level:
        self.assertEqual(perf_res['recall_events'], 0)
        self.assertEqual(perf_res['precision_events'], np.inf)
        self.assertTrue(np.isnan(perf_res['f1score_events']))
        
        correct_conf_matrix_events = np.array([0, 0,
                                               0, 3
                                               ])
        self.assertEqual(np.all(perf_res.confusion_matrix_events()),
                         np.all(correct_conf_matrix_events)
                         )

    #------------------------------------
    # test_compute_performance
    #-------------------    

    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_compute_performance(self):
        '''
        Test cases using sample2:

        2. First burst is false negative:
           audio mask:  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0

        '''

        # To make arrays small:
        self.pr_comp.framerate = 2
        
        # SAMPLE 2: Audio has two false negatives
        
        perf_res = self.pr_comp.compute_performance(None,
                                                    self.samples2, 
                                                    self.tiny_labels_path, 
                                                    100) # 100% overlap for success
        
        self.assertEqual(np.round(perf_res['recall_events'], 2), 0.0)
        self.assertEqual(perf_res['precision_events'], np.inf)
        self.assertTrue(np.isnan(perf_res['f1score_events']))

        self.assertEqual(np.round(perf_res['recall_samples'], 2), 0.55) # 6/11
        self.assertEqual(np.round(perf_res['precision_samples'], 2), 1) # no false positives
        self.assertEqual(np.round(perf_res['f1score_samples'], 2), 0.71)
        
        correct_conf_matrix_events = np.array([0, 0,
                                               1, 3
                                               ])
        correct_conf_matrix_samples = np.array([6, 0,
                                                5, 7
                                                ])
        self.assertEqual(np.all(perf_res.confusion_matrix_events()),
                         np.all(correct_conf_matrix_events)
                         )
        self.assertEqual(np.all(perf_res.confusion_matrix_samples()),
                         np.all(correct_conf_matrix_samples)
                         )

    #------------------------------------
    # test_false_positive
    #------------------- 
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_false_positive(self):
        '''
        3. The third element of the four negatives after the second burst
           is a false positive:
           audio mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0

        '''
        # To make arrays small:
        self.pr_comp.framerate = 2
        
        # SAMPLE 3: Audio has one false positive:
        
        perf_res = self.pr_comp.compute_performance(None,
                                                    self.samples3,
                                                    self.tiny_labels_path, 
                                                    100) # 100% overlap for success
        
        self.assertEqual(np.round(perf_res['recall_events'], 2), 0.0)
        self.assertEqual(np.round(perf_res['precision_events'], 2), 0.00)
        self.assertEqual(perf_res['f1score_events'], np.inf)

        self.assertEqual(np.round(perf_res['recall_samples'], 2), 0.73)
        self.assertEqual(np.round(perf_res['precision_samples'], 2), 0.89)
        self.assertEqual(np.round(perf_res['f1score_samples'], 2), 0.8)
        
        correct_conf_matrix_events = np.array([0, 1,
                                               0, 2
                                               ])
        correct_conf_matrix_samples = np.array([8, 1,
                                                3, 6
                                                ])
        self.assertEqual(np.all(perf_res.confusion_matrix_events()),
                         np.all(correct_conf_matrix_events)
                         )
        self.assertEqual(np.all(perf_res.confusion_matrix_samples()),
                         np.all(correct_conf_matrix_samples)
                         )

    #------------------------------------
    # test_false_positives_at_edges
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_false_positives_at_edges(self):
        '''
        4. First and last elements are false positive: 
           audio mask:  1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0

        '''
        # To make arrays small:
        self.pr_comp.framerate = 2
        
        # SAMPLE 4: Audio has two false positive; one at each end:
        
        perf_res = self.pr_comp.compute_performance(None,
                                                    self.samples4, 
                                                    self.tiny_labels_path, 
                                                    100) # 100% overlap for success
        
        self.assertEqual(np.round(perf_res['recall_events'], 2), 0.33)
        self.assertEqual(np.round(perf_res['precision_events'], 2), 0.5)  # 1 right, 1 wrong
        self.assertEqual(np.round(perf_res['f1score_events'], 2), 0.4)

        self.assertEqual(np.round(perf_res['recall_samples'], 2), 0.82)
        self.assertEqual(np.round(perf_res['precision_samples'], 2), 0.9) # 8/11: 2 false positive samples of 10 claimed
        self.assertEqual(np.round(perf_res['f1score_samples'], 2), 0.86)
        
        correct_conf_matrix_events = np.array([1, 1,
                                               0, 2
                                               ])
        correct_conf_matrix_samples = np.array([9, 1,
                                                2, 6
                                                ])
        self.assertEqual(np.all(perf_res.confusion_matrix_events()),
                         np.all(correct_conf_matrix_events)
                         )
        self.assertEqual(np.all(perf_res.confusion_matrix_samples()),
                         np.all(correct_conf_matrix_samples)
                         )

    #------------------------------------
    # test_partial_overlap_ok
    #-------------------
    
    @unittest.skipIf(not TEST_ALL, "Temporarily skipping")
    def test_partial_overlap_ok(self):
        '''
        6. Insufficient overlap (50%)
           audio mask:  0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0 
             ele mask:  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0
        
        '''

        # To make arrays small:
        self.pr_comp.framerate = 2
        
        # SAMPLE 6: Audio has same number of 1s, but one
        #           event is shifted right by 50%:
        
        perf_res = self.pr_comp.compute_performance(None,
                                                    self.samples6, 
                                                    self.tiny_labels_path, 
                                                    0.5) # 50% overlap for success            
        
        self.assertEqual(np.round(perf_res['recall_events'], 2), 1.0)
        self.assertEqual(np.round(perf_res['precision_events'], 2), 1.0)
        self.assertEqual(np.round(perf_res['f1score_events'], 2), 1.0)

        self.assertEqual(np.round(perf_res['recall_samples'], 2), 0.64)
        self.assertEqual(np.round(perf_res['precision_samples'], 2), 0.88)
        self.assertEqual(np.round(perf_res['f1score_samples'], 2), 0.74)
        
        correct_conf_matrix_events = np.array([3, 0,
                                               0, 3
                                               ])
        correct_conf_matrix_samples = np.array([7, 1,
                                                4, 6
                                                ])
        self.assertEqual(np.all(perf_res.confusion_matrix_events()),
                         np.all(correct_conf_matrix_events)
                         )
        self.assertEqual(np.all(perf_res.confusion_matrix_samples()),
                         np.all(correct_conf_matrix_samples)
                         )

# --------------------------- Utils ---------------------

    #------------------------------------
    # read_labels
    #-------------------    

    def read_labels(self):

        label_file_path = os.path.join(os.path.dirname(__file__), 
                                       'labels_for_testing.txt')   
        labeled_events = self.pr_comp.label_file_reader(label_file_path)
        return labeled_events 

# --------------------------- Main ---------------
        
if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()